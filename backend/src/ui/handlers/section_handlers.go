package handlers

import (
	"fmt"
	"net/http"

	"github.com/a-h/templ"
	"go.uber.org/zap"

	"github.com/stommydx/VibeFolio/backend/src/ui/htmx"
	"github.com/stommydx/VibeFolio/backend/src/ui/pages"
)

// SectionHandlers handles section-related HTTP requests for UI
type SectionHandlers struct {
	logger *zap.Logger
}

// NewSectionHandlers creates new section handlers
func NewSectionHandlers(logger *zap.Logger) *SectionHandlers {
	return &SectionHandlers{
		logger: logger,
	}
}

// AddSectionHandler handles the POST /profiles/{profileId}/sections endpoint for UI
func (h *SectionHandlers) AddSectionHandler(w http.ResponseWriter, r *http.Request) {
	// In a real implementation, this would:
	// 1. Get the authenticated user
	// 2. Parse form data
	// 3. Create a new section using the service
	// 4. Render the new section or redirect
	
	// For now, we'll just render a mock section
	h.logger.Info("Adding new section")
	
	// Mock section
	sectionID := "3" // This would be generated by the service in a real implementation
	profileID := "1" // This would be extracted from the URL in a real implementation
	title := "New Section"
	content := "Section content..."
	
	// If this is an HTMX request, render just the section
	if r.Header.Get("HX-Request") == "true" {
		component := htmx.SectionItem(sectionID, profileID, title, content)
		
		// Set content type
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		
		// Render the component
		if err := component.Render(r.Context(), w); err != nil {
			http.Error(w, "Failed to render section", http.StatusInternalServerError)
			return
		}
	} else {
		// Otherwise, redirect to the profile page
		http.Redirect(w, r, "/profiles/"+profileID, http.StatusSeeOther)
	}
}

// DeleteSectionHandler handles the DELETE /profiles/{profileId}/sections/{sectionId} endpoint for UI
func (h *SectionHandlers) DeleteSectionHandler(w http.ResponseWriter, r *http.Request) {
	// In a real implementation, this would:
	// 1. Get the authenticated user
	// 2. Delete the section using the service
	// 3. Return appropriate response for HTMX
	
	// For now, we'll just return a success response
	h.logger.Info("Deleting section")
	
	// If this is an HTMX request, return empty response to remove the element
	if r.Header.Get("HX-Request") == "true" {
		// HTMX will remove the element, so we just return 200 OK
		w.WriteHeader(http.StatusOK)
	} else {
		// Otherwise, redirect to the profile page
		profileID := "1" // This would be extracted from the URL in a real implementation
		http.Redirect(w, r, "/profiles/"+profileID, http.StatusSeeOther)
	}
}

// AddSectionFormHandler handles the GET /profiles/{profileId}/sections/new endpoint for UI
func (h *SectionHandlers) AddSectionFormHandler(w http.ResponseWriter, r *http.Request) {
	// In a real implementation, this would:
	// 1. Get the authenticated user
	// 2. Render the add section form
	
	// For now, we'll just render a mock form
	h.logger.Info("Rendering add section form")
	
	profileID := "1" // This would be extracted from the URL in a real implementation
	
	component := htmx.AddSectionForm(profileID)
	
	// Set content type
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	
	// Render the component
	if err := component.Render(r.Context(), w); err != nil {
		http.Error(w, "Failed to render form", http.StatusInternalServerError)
		return
	}
}